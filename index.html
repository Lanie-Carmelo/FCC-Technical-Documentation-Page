<!DOCTYPE html>
<html>
  <head>
    <title>Basic Python Tutorial</title>
    <meta charset="UTF-8" />
    <link href="styles.css" rel="stylesheet" />
  </head>

  <body>
    <nav id="navbar">
      <header id="nav-header">Table of Contents</header>
      <a href="#About_This_Tutorial" class="nav-link">About This Tutorial</a>
      <a href="#HELLO,_WORLD!" class="nav-link">Hello, World!</a>
      <a href="#Variables_and_Types" class="nav-link">Variables and Types</a>
      <a href="#Lists" class="nav-link">Lists</a>
      <a href="#Basic_Operators" class="nav-link">Basic Operators</a>
      <a href="#String_Formatting" class="nav-link">String Formatting</a>
      <a href="#Basic_String_Operations" class="nav-link">Basic String Operations</a>
      <a href="#Conditions" class="nav-link">Conditions</a>
      <a href="#Loops" class="nav-link">Loops</a>
      <a href="#Functions" class="nav-link">Functions</a>
      <a href="#Classes_and_Objects" class="nav-link">Classes and Objects</a>
      <a href="#Dictionaries" class="nav-link">Dictionaries</a>
      <a href="#Modules_and_Packages" class="nav-link">Modules and Packages</a>
      <a href="#References" class="nav-link">References</a>
    </nav>
    <main id="main-doc">
            <header><h1>Basic Python Tutorial</h1></header>
      <section id="About_This_Tutorial" class="main-section">
        <header><h2>About This Tutorial</h2></header>
        <p>This tutorial will teach you the basics of the Python programming language. You do not need any programming experience to begin, although basic computer skills are required. When code examples shown would print something, I included their output below the example.</p>
        <p>This tutorial does not contain exercises. For an interactive tutorial with exercises and code editors where you can try things yourself, go to the website linked in the References section.</p>
      </section>
      <section id="HELLO,_WORLD!" class="main-section">
        <header><h2>Hello, World!</h2></header>
        <p>Python is a very simple language, and has a very straightforward syntax. It encourages programmers to program without boilerplate (prepared) code. The simplest directive in Python is the "print" directive - it simply prints out a line (and also includes a newline, unlike in C).</p>
        <p>There are two major Python versions, Python 2 and Python 3. Python 2 and 3 are quite different. This tutorial uses Python 3, because it more semantically correct and supports newer features.</p>
        <p>For example, one difference between Python 2 and 3 is the print statement. In Python 2, the "print" statement is not a function, and therefore it is invoked without parentheses. However, in Python 3, it is a function, and must be invoked with parentheses.</p>
        <p>To print a string in Python 3, just write:</p>
        <code>print("This line will be printed.")</code>
        <p>The code above results in the following output:</p>
        <samp>This line will be printed.</samp>
        <h3>Indentation</h3>
        <p>Python uses indentation for blocks, instead of curly braces. Both tabs and spaces are supported, but the standard indentation requires standard Python code to use four spaces. For example:</p>
<pre><code>x = 1
if x == 1:
    # indented four spaces
    print("x is 1."</code></pre>
      <p>The code above results in the following output:</p>
      <samp>x is 1.</samp>
      </section>
      <section id="Variables_and_Types" class="main-section">
        <header><h2>Variables and Types</h2></header>
        <p>Python is completely object oriented, and not "statically typed". You do not need to declare variables before using them, or declare their type. Every variable in Python is an object.</p>
        <p>This tutorial will go over a few basic types of variables.</p>
        <h3>Numbers</h3>
        <p>Python supports two types of numbers - integers(whole numbers) and floating point numbers(decimals). (It also supports complex numbers, which will not be explained in this tutorial).</p>
        <p>To define an integer, use the following syntax:</p>
<pre><code>myint = 7
print(myint)</code</pre>
        <p>The code above results in the following output:</p>
        <samp>7</samp>
        <p>To define a floating point number, you may use one of the following notations:</p>
<pre><code>myfloat = 7.0
print(myfloat)
myfloat = float(7)
print(myfloat)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>7.0
7.0</samp></pre>
        <h3>Strings</h3>
        <p>Strings are defined either with a single quote or double quotes.</p>
<pre><code>mystring = 'hello'
print(mystring)
mystring = "hello"
print(mystring)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>hello
hello</samp></pre>
        <p>The difference between the two is that using double quotes makes it easy to include apostrophes (whereas these would terminate the string if using single quotes)</p>
<pre><code>mystring = "Don't worry about apostrophes"
print(mystring)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>Don't worry about apostrophes</samp>
        <p>There are additional variations on defining strings that make it easier to include things such as carriage returns, backslashes and Unicode characters. These are beyond the scope of this tutorial, but are covered in the <a href="https://docs.python.org/tutorial/introduction.html#strings">Python documentation</a>.</p>
        <p>Simple operators can be executed on numbers and strings:</p>
<pre><code>one = 1
two = 2
three = one + two
print(three)
    
hello = "hello"
world = "world"
helloworld = hello + " " + world
print(helloworld)</code></pre>
        <p>The code above results in the following output:</p>
<pre></samp>3
hello world</samp></pre>
        <p>Assignments can be done on more than one variable "simultaneously" on the same line like this</p>
<pre><code>a, b = 3, 4
print(a,b)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>3 4</samp>
<p>Mixing operators between numbers and strings is not supported:</p>
<pre><code># This will not work!
one = 1
two = 2
hello = "hello"

print(one + two + hello)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
    print(one + two + hello)
TypeError: unsupported operand type(s) for +: 'int' and 'str'</samp></pre>
      </section>
      <section id="Lists" class="main-section">
        <header><h2>Lists</h2></header>
        <p>Lists are very similar to arrays. They can contain any type of variable, and they can contain as many variables as you wish. Lists can also be iterated over in a very simple manner. Here is an example of how to build a list.</p>
<pre><code>mylist = []
mylist.append(1)
mylist.append(2)
mylist.append(3)
print(mylist[0]) # prints 1
print(mylist[1]) # prints 2
print(mylist[2]) # prints 3

# prints out 1,2,3
for x in mylist:
print(x)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>1
2
3
1
2
3</samp></pre>
        <p> Accessing an index which does not exist generates an exception (an error).</p>
<pre><code>mylist = [1,2,3]
        <p>The code above results in the following output:</p>
<pre><samp>    print(mylist[10])
    IndexError: list index out of range</samp></pre>
      </section>
      <section id="Basic_Operators" class="main-section">
        <header><h2>Basic Operators</h2></header>
        <p>This section explains how to use basic operators in Python.</p>
        <h3>Arithmetic Operators</h3>
        <p>Just as any other programming languages, the addition, subtraction, multiplication, and division operators can be used with numbers.</p>
<pre><code>number = 1 + 2 * 3 / 4.0
print(number)</code></pre>
        <p>The above code results in the following output:</p>
        <samp>2.5</samp>
        <p>Try to predict what the answer will be. Does python follow order of operations?</p>
        <p>Another operator available is the modulo (%) operator, which returns the integer remainder of the division. dividend % divisor = remainder.</p>
<pre><code>remainder = 11 % 3
print(remainder)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>2</samp>
        <p>Using two multiplication symbols makes a power relationship.</p>
<pre><code>squared = 7 ** 2
cubed = 2 ** 3
print(squared)
print(cubed)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>49
8</samp></pre>
        <h3>Using Operators with Strings</h3>
        <p>Python supports concatenating strings using the addition operator:</p>
<pre><code>helloworld = "hello" + " " + "world"
print(helloworld)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>hello world</samp>
        <p>Python also supports multiplying strings to form a string with a repeating sequence:</p>
<pre><code>lotsofhellos = "hello" * 10
print(lotsofhellos)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>hellohellohellohellohellohellohellohellohellohello</samp>
        <h3>Using Operators with Lists</h3>
        <p>Lists can be joined with the addition operators:</p>
<pre><code>even_numbers = [2,4,6,8]
odd_numbers = [1,3,5,7]
all_numbers = odd_numbers + even_numbers
print(all_numbers)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>[1, 3, 5, 7, 2, 4, 6, 8]</samp>
        <p>Just as in strings, Python supports forming new lists with a repeating sequence using the multiplication operator:</p>
        <code>print([1,2,3] * 3)</code>
        <p>The code above results in the following output:</p>
        <samp>[1, 2, 3, 1, 2, 3, 1, 2, 3]</samp>
      </section>
      <section id="String_Formatting" class="main-section">
        <header><h2>String Formatting</h2></header>
        <p>Python uses C-style string formatting to create new, formatted strings. The "%" operator is used to format a set of variables enclosed in a "tuple" (a fixed size list), together with a format string, which contains normal text together with "argument specifiers", special symbols like "%s" and "%d".</p>
        <p>Let's say you have a variable called "name" with your user name in it, and you would then like to print(out a greeting to that user.)</p>
<pre><code># This prints out "Hello, John!"
name = "John"
print("Hello, %s!" % name)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>Hello, John!</samp>
        <p>To use two or more argument specifiers, use a tuple (parentheses):</p>
<pre><code># This prints out "John is 23 years old."
name = "John"
age = 23
print("%s is %d years old." % (name, age))</code></pre>
        <p>The code above results in the following output:</p>
        <samp>John is 23 years old.</samp>
        <p>Any object which is not a string can be formatted using the %s operator as well. The string which returns from the "repr" method of that object is formatted as the string. For example:</p>
<pre><code># This prints out: A list: [1, 2, 3]
mylist = [1,2,3]
print("A list: %s" % mylist)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>A list: [1, 2, 3]</samp>
        <p>Here are some basic argument specifiers you should know:</p>
        <ul>
          <li>%s - String (or any object with a string representation, like numbers)</li>
          <li>%d - Integers</li>
          <li>%f - Floating point numbers</li>
          <li>%.<number of digits>f - Floating point numbers with a fixed amount of digits to the right of the dot.</li>
          <li>%x/%X - Integers in hex representation (lowercase/uppercase)</li>
        </ul>
      </section>
      <section id="Basic_String_Operations" class="main-section">
        <header><h2>Basic String Operations</h2></header>
        <p>Strings are bits of text. They can be defined as anything between quotes:</p>
<pre><code>astring = "Hello world!"
astring2 = 'Hello world!'</code></pre>
        <p>As you can see, the first thing you learned was printing a simple sentence. This sentence was stored by Python as a string. However, instead of immediately printing strings out, we will explore the various things you can do to them. You can also use single quotes to assign a string. However, you will face problems if the value to be assigned itself contains single quotes. For example to assign the string in these bracket(single quotes are ' ') you need to use double quotes only like this</p>
<pre><code>astring = "Hello world!"
print("single quotes are ' '")

print(len(astring))</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>single quotes are ' '
12</samp></pre>
        <p>That prints out 12, because "Hello world!" is 12 characters long, including punctuation and spaces.</p>
<pre><code>astring = "Hello world!"
print(astring.index("o"))</code></pre>
        <p>The code above results in the following output:</p>
        <samp>4</samp>
        <p>That prints out 4, because the location of the first occurrence of the letter "o" is 4 characters away from the first character. Notice how there are actually two o's in the phrase - this method only recognizes the first.</p>
        <p>But why didn't it print out 5? Isn't "o" the fifth character in the string? To make things more simple, Python (and most other programming languages) start things at 0 instead of 1. So the index of "o" is 4.</p>
<pre><code>astring = "Hello world!"
print(astring.count("l"))</code></pre>
        <p>The code above results in the following output:</p>
        <samp>3</samp>
        <p>For those of you using silly fonts, that is a lowercase L, not a number one. This counts the number of l's in the string. Therefore, it should print 3.</p>
<pre><code>astring = "Hello world!"
print(astring[3:7])</code></pre>
        <p>The code above results in the following output:</p>
        <samp>lo w</samp>
        <p>This prints a slice of the string, starting at index 3, and ending at index 6. But why 6 and not 7? Again, most programming languages do this - it makes doing math inside those brackets easier.</p>
        <p>If you just have one number in the brackets, it will give you the single character at that index. If you leave out the first number but keep the colon, it will give you a slice from the start to the number you left in. If you leave out the second number, it will give you a slice from the first number to the end.</p>
        <p>You can even put negative numbers inside the brackets. They are an easy way of starting at the end of the string instead of the beginning. This way, -3 means "3rd character from the end".</p>
<pre><code>astring = "Hello world!"
print(astring[3:7:2])</code></pre>
        <p>The code above results in the following output:</p>
        <samp>l </samp>
        <p>This prints the characters of string from 3 to 7 skipping one character. This is extended slice syntax. The general form is [start:stop:step].</p>
<pre><code>astring = "Hello world!"
print(astring[3:7])
print(astring[3:7:1])</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>lo w
lo w</samp></pre>
        <p>Note that both of them produce same output</p>
        <p>There is no function like strrev in C to reverse a string. But with the above mentioned type of slice syntax you can easily reverse a string like this</p>
<pre><code>astring = "Hello world!"
print(astring[::-1])</code></pre>
        <p>The code above results in the following output:</p>
        <samp>!dlrow olleH</samp>
        <p>These make a new string with all letters converted to uppercase and lowercase, respectively.</p>
<pre><code>astring = "Hello world!"
print(astring.upper())
print(astring.lower())</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>HELLO WORLD!
hello world!</samp></pre>
        <p>This is used to determine whether the string starts with something or ends with something, respectively. The first one will print True, as the string starts with "Hello". The second one will print False, as the string certainly does not end with "asdfasdfasdf".</p>
<pre><code>astring = "Hello world!"
print(astring.startswith("Hello"))
print(astring.endswith("asdfasdfasdf"))</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>True
False</samp></pre>
        <p>This splits the string into a bunch of strings grouped together in a list. Since this example splits at a space, the first item in the list will be "Hello", and the second will be "world!".</p>
<pre><code>astring = "Hello world!"
afewwords = astring.split(" ")</code></pre>
      </section>
      <section id="Conditions" class="main-section">
        <header><h2>Conditions</h2></header>
        <p>Python uses boolean logic to evaluate conditions. The boolean values True and False are returned when an expression is compared or evaluated. For example:</p>
<pre><code>x = 2
print(x == 2) # prints out True
print(x == 3) # prints out False
print(x < 3) # prints out True </code></pre>
        <p>The code above results in the following output:</p>]
<pre><code>True
False
True</code></pre>
        <p>Notice that variable assignment is done using a single equals operator "=", whereas comparison between two variables is done using the double equals operator "==". The "not equals" operator is marked as "!=".</p>
        <h3>Boolean operators</h3>
        <p>The "and" and "or" boolean operators allow building complex boolean expressions, for example:</p>
<pre><code>name = "John"
age = 23
if name == "John" and age == 23:
    print("Your name is John, and you are also 23 years old.")

if name == "John" or name == "Rick":
    print("Your name is either John or Rick.")</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>Your name is John, and you are also 23 years old.
Your name is either John or Rick.</samp></pre>
        <h3>The "in" operator</h3>
        <p>The "in" operator could be used to check if a specified object exists within an iterable object container, such as a list:</p>
<pre><code>name = "John"
if name in ["John", "Rick"]:
    print("Your name is either John or Rick.")</code></pre>
        <p>The code above results in the following output:</p>
        <samp>Your name is either John or Rick.</samp>
        <p>Python uses indentation to define code blocks, instead of brackets. The standard Python indentation is 4 spaces, although tabs and any other space size will work, as long as it is consistent. Notice that code blocks do not need any termination.</p>
        <p>Here is an example for using Python's "if" statement using code blocks:</p>
<pre><code>statement = False
another_statement = True
if statement is True:
    # do something
    pass
elif another_statement is True: # else if
    # do something else
    pass
else:
    # do another thing
    pass</code></pre>
        <p>For example:</p>
<pre><code>x = 2
if x == 2:
    print("x equals two!")
else:
    print("x does not equal to two.")</code></pre>
        <p>The code above results in the following output:</p>
        <samp>x equals two!</samp>
        <p>A statement is evaluated as true if one of the following is correct:</p>
        <ol>
          <li>The "True" boolean variable is given, or calculated using an expression, such as an arithmetic comparison.</li>
          <li>An object which is not considered "empty" is passed.</li>
        </ol>
        <p>Here are some examples for objects which are considered as empty: 1. An empty string: "" 2. An empty list: [] 3. The number zero: 0 4. The false boolean variable: False</p>
        <h3>The 'is' operator</h3>
        <p>Unlike the double equals operator "==", the "is" operator does not match the values of the variables, but the instances themselves. For example:</p>
<pre><code>x = [1,2,3]
y = [1,2,3]
print(x == y) # Prints out True
print(x is y) # Prints out False</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>True
False</samp></pre>
        <h3>The "not" operator</h3>
        <p>Using "not" before a boolean expression inverts it:</p>]
<pre><code>print(not False) # Prints out True
print((not False) == (False)) # Prints out False</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>True
False</samp></pre>
      </section>
      <section id="Loops" class="main-section">
        <header><h2>Loops</h2></header>
        <p>There are two types of loops in Python, for and while.</p>
        <h3>The "for" loop</h3>
        <p>For loops iterate over a given sequence. Here is an example:</p>
<pre><code>primes = [2, 3, 5, 7]
for prime in primes:
    print(prime)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>2
3
5
7</samp></pre>
        <p>For loops can iterate over a sequence of numbers using the "range" and "xrange" functions. The difference between range and xrange is that the range function returns a new list with numbers of that specified range, whereas xrange returns an iterator, which is more efficient. (Python 3 uses the range function, which acts like xrange). Note that the range function is zero based.</p>
<pre><code># Prints out the numbers 0,1,2,3,4
for x in range(5):
    print(x)

# Prints out 3,4,5
for x in range(3, 6):
    print(x)

# Prints out 3,5,7
for x in range(3, 8, 2):
    print(x)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>0
1
2
3
4
3
4
5
3
5
7</samp></pre>
        <h3>"while" loops</h3>
        <p>While loops repeat as long as a certain boolean condition is met. For example:</p>
<pre><code># Prints out 0,1,2,3,4

count = 0
while count < 5:
    print(count)
    count += 1  # This is the same as count = count + 1</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>0
1
2
3
4</samp></pre>
        <h3>"break" and "continue" statements</h3>
        <p>Break is used to exit a for loop or a while loop, whereas continue is used to skip the current block, and return to the "for" or "while" statement. A few examples:</p>
<pre><code># Prints out 0,1,2,3,4

count = 0
while True:
    print(count)
    count += 1
    if count >= 5:
        break

# Prints out only odd numbers - 1,3,5,7,9
for x in range(10):
    # Check if x is even
    if x % 2 == 0:
        continue
    print(x)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>0
1
2
3
4
1
3
5
7
9</samp></pre>
        <h3>Can we use "else" clause for loops?</h3>
        <p>Unlike languages like C,CPP.. we can use else for loops. When the loop condition of "for" or "while" statement fails then code part in "else" is executed. If a break statement is executed inside the for loop then the "else" part is skipped. Note that the "else" part is executed even if there is a continue statement.</p>
        <p>Here are a few examples:</p>
<pre><code># Prints out 0,1,2,3,4 and then it prints "count value reached 5"

count=0
while(count<5):
    print(count)
    count +=1
else:
    print("count value reached %d" %(count))

# Prints out 1,2,3,4
for i in range(1, 10):
    if(i%5==0):
        break
    print(i)
else:
    print("this is not printed because for loop is terminated because of break but not due to fail in condition")</code></pre>
        <p>The code above results in the following output:</p>
<pre><code>0
1
2
3
4
count value reached 5
1
2
3
4</code></pre>
      </section>
      <section id="Functions" class="main-section">
        <header><h2>Functions</h2></header>
        <h3>What are Functions?</h3>
        <p>Functions are a convenient way to divide your code into useful blocks, allowing us to order our code, make it more readable, reuse it and save some time. Also functions are a key way to define interfaces so programmers can share their code.</p>
        <h3>How do you write functions in Python?</h3>
        <p>As we have seen on previous tutorials, Python makes use of blocks.</p>
        <p>A block is a area of code of written in the format of:</p>
<pre><code>block_head:
    1st block line
    2nd block line
    ...</code></pre>
        <p>Where a block line is more Python code (even another block), and the block head is of the following format: block_keyword block_name(argument1,argument2, ...) Block keywords you already know are "if", "for", and "while".</p>
        <p>Functions in python are defined using the block keyword "def", followed with the function's name as the block's name. For example:</p>
<pre><code>def my_function():
    print("Hello From My Function!")</code></pre>
        <p>Functions may also receive arguments (variables passed from the caller to the function). For example:</p>
<pre><code>def my_function_with_args(username, greeting):
    print("Hello, %s , From My Function!, I wish you %s"%(username, greeting))</code></pre>
        <p>Functions may return a value to the caller, using the keyword- 'return' . For example:</p>
<pre><code>def sum_two_numbers(a, b):
    return a + b</code></pre>
        <h3>How do you call functions in Python?</h3>
        <p>Simply write the function's name followed by (), placing any required arguments within the brackets. For example, lets call the functions written above (in the previous example):</p>
<pre><code># Define our 3 functions
def my_function():
    print("Hello From My Function!")

def my_function_with_args(username, greeting):
    print("Hello, %s, From My Function!, I wish you %s"%(username, greeting))

def sum_two_numbers(a, b):
    return a + b

# print(a simple greeting)
my_function()

#prints - "Hello, John Doe, From My Function!, I wish you a great year!"
my_function_with_args("John Doe", "a great year!")

# after this line x will hold the value 3!
x = sum_two_numbers(1,2)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>Hello From My Function!
Hello, John Doe, From My Function!, I wish you a great year!</samp></pre>
      </section>
      <section id="Classes_and_Objects" class="main-section">
        <header><h2>Classes and Objects</h2></header>
        <p>Objects are an encapsulation of variables and functions into a single entity. Objects get their variables and functions from classes. Classes are essentially a template to create your objects.</p>
        <p>A very basic class would look something like this:</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")</code></pre>
        <p>We'll explain why you have to include that "self" as a parameter a little bit later. First, to assign the above class(template) to an object you would do the following:</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")

myobjectx = MyClass()</code></pre>
        <p>Now the variable "myobjectx" holds an object of the class "MyClass" that contains the variable and the function defined within the class called "MyClass".</p>]
        <h3>Accessing Object Variables</h3>
        <p>To access the variable inside of the newly created object "myobjectx" you would do the following:</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")

myobjectx = MyClass()

myobjectx.variable</code></pre>
        <p>So for instance the below would output the string "blah":</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")

myobjectx = MyClass()

print(myobjectx.variable)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>blah</samp>
        <p>You can create multiple different objects that are of the same class(have the same variables and functions defined). However, each object contains independent copies of the variables defined in the class. For instance, if we were to define another object with the "MyClass" class and then change the string in the variable above:</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")

myobjectx = MyClass()
myobjecty = MyClass()

myobjecty.variable = "yackity"

# Then print out both values
print(myobjectx.variable)
print(myobjecty.variable)</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>blah
yackity</samp></pre>
        <h3>Accessing Object Functions</h3>
        <p>To access a function inside of an object you use notation similar to accessing a variable:</p>
<pre><code>class MyClass:
    variable = "blah"

    def function(self):
        print("This is a message inside the class.")

myobjectx = MyClass()

myobjectx.function()</code></pre>
        <p>The above would print out the message, "This is a message inside the class."</p>
      </section>
      <section id="Dictionaries" class="main-section">
        <header><h2>Dictionaries</h2></header>
        <p>A dictionary is a data type similar to arrays, but works with keys and values instead of indexes. Each value stored in a dictionary can be accessed using a key, which is any type of object (a string, a number, a list, etc.) instead of using its index to address it.</p>
        <p>For example, a database of phone numbers could be stored using a dictionary like this:</p>
<pre><code>phonebook = {}
phonebook["John"] = 938477566
phonebook["Jack"] = 938377264
phonebook["Jill"] = 947662781
print(phonebook)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>{'Jill': 947662781, 'John': 938477566, 'Jack': 938377264}</samp>
        <p>Alternatively, a dictionary can be initialized with the same values in the following notation:</p>
<pre<code>phonebook = {
    "John" : 938477566,
    "Jack" : 938377264,
    "Jill" : 947662781
}
print(phonebook)</pre<code>
        <p>The code above results in the following output:</p>
        <samp>{'Jill': 947662781, 'John': 938477566, 'Jack': 938377264}</samp>
        <h3>Iterating over dictionaries</h3>
        <p>Dictionaries can be iterated over, just like a list. However, a dictionary, unlike a list, does not keep the order of the values stored in it. To iterate over key value pairs, use the following syntax:</p>
<pre><code>phonebook = {"John" : 938477566,"Jack" : 938377264,"Jill" : 947662781}
for name, number in phonebook.items():
    print("Phone number of %s is %d" % (name, number))</code></pre>
        <p>The code above results in the following output:</p>
<pre><samp>Phone number of Jill is 947662781
Phone number of John is 938477566
Phone number of Jack is 938377264</samp></pre>
        <h3>Removing a value</h3>
        <p>To remove a specified index, use either one of the following notations:</p>
<pre><code>phonebook = {
   "John" : 938477566,
   "Jack" : 938377264,
   "Jill" : 947662781
}
del phonebook["John"]
print(phonebook)</code></pre>
        <p>The code above results in the following output:</p>
        <samp>{'Jack': 938377264, 'Jill': 947662781}</samp>
        <p>Or:</p>
<Pre><code>phonebook = {
   "John" : 938477566,
   "Jack" : 938377264,
   "Jill" : 947662781
}
phonebook.pop("John")
print(phonebook)</code></Pre>
        <p>The code above results in the following output:</p>
        <samp>{'Jack': 938377264, 'Jill': 947662781}</samp>
      </section>
      <section id="Modules_and_Packages" class="main-section">
        <header><h2>Modules and Packages</h2></header>
        <p>In programming, a module is a piece of software that has a specific functionality. For example, when building a ping pong game, one module would be responsible for the game logic, and another module would be responsible for drawing the game on the screen. Each module is a different file, which can be edited separately.</p>
        <h3>Writing modules</h3>
        <p>Modules in Python are simply Python files with a .py extension. The name of the module will be the name of the file. A Python module can have a set of functions, classes or variables defined and implemented. In the example above, we will have two files, we will have:</p>
<pre><code>mygame/
mygame/game.py
mygame/draw.py</code></pre>
        <p>The Python script game.py will implement the game. It will use the function draw_game from the file draw.py, or in other words, the draw module, that implements the logic for drawing the game on the screen.</p>
        <p>Modules are imported from other modules using the import command. In this example, the game.py script may look something like this:</p>
<pre><code># game.py
# import the draw module
import draw

def play_game():
    ...

def main():
    result = play_game()
    draw.draw_game(result)

# this means that if this script is executed, then 
# main() will be executed
if __name__ == '__main__':
    main()</code></pre>
        <p>The draw module may look something like this:</p>
<pre><code># draw.py

def draw_game():
    ...

def clear_screen(screen):
    ...</code></pre>
        <p>In this example, the game module imports the draw module, which enables it to use functions implemented in that module. The main function would use the local function play_game to run the game, and then draw the result of the game using a function implemented in the draw module called draw_game. To use the function draw_game from the draw module, we would need to specify in which module the function is implemented, using the dot operator. To reference the draw_game function from the game module, we would need to import the draw module and only then call draw.draw_game().</p>
        <p>When the import draw directive will run, the Python interpreter will look for a file in the directory which the script was executed from, by the name of the module with a .py suffix, so in our case it will try to look for draw.py. If it will find one, it will import it. If not, it will continue to look for built-in modules.</p>
        <p>You may have noticed that when importing a module, a .pyc file appears, which is a compiled Python file. Python compiles files into Python bytecode so that it won't have to parse the files each time modules are loaded. If a .pyc file exists, it gets loaded instead of the .py file, but this process is transparent to the user.</p>
        <h3>Importing module objects to the current namespace</h3>
        <p>We may also import the function draw_game directly into the main script's namespace, by using the from command.</p>
<pre><code># game.py
# import the draw module
from draw import draw_game

def main():
    result = play_game()
    draw_game(result)</code></pre>
        <p>You may have noticed that in this example, draw_game does not precede with the name of the module it is imported from, because we've specified the module name in the import command.</p>
        <p>The advantages of using this notation is that it is easier to use the functions inside the current module because you don't need to specify which module the function comes from. However, any namespace cannot have two objects with the exact same name, so the import command may replace an existing object in the namespace.</p>
        <h3>Importing all objects from a module</h3>
        <p>We may also use the import * command to import all objects from a specific module, like this:</p>
<pre><code># game.py
# import the draw module
from draw import *

def main():
    result = play_game()
    draw_game(result)</code></pre>
        <p>This might be a bit risky as changes in the module might affect the module which imports it, but it is shorter and also does not require you to specify which objects you wish to import from the module.</p>
        <h3>Custom import name</h3>
        <p>We may also load modules under any name we want. This is useful when we want to import a module conditionally to use the same name in the rest of the code.</p>
        <p>For example, if you have two draw modules with slighty different names - you may do the following:</p>
<pre><code># game.py
# import the draw module
if visual_mode:
    # in visual mode, we draw using graphics
    import draw_visual as draw
else:
    # in textual mode, we print out text
    import draw_textual as draw

def main():
    result = play_game()
    # this can either be visual or textual depending on visual_mode
    draw.draw_game(result)</code></pre>
        <h3>Module initialization</h3>
        <p>The first time a module is loaded into a running Python script, it is initialized by executing the code in the module once. If another module in your code imports the same module again, it will not be loaded twice but once only - so local variables inside the module act as a "singleton" - they are initialized only once.</p>
        <p>This is useful to know, because this means that you can rely on this behavior for initializing objects. For example:</p>
<pre><code># draw.py

def draw_game():
    # when clearing the screen we can use the main screen object initialized in this module
    clear_screen(main_screen)
    ...

def clear_screen(screen):
    ...

class Screen():
    ...

# initialize main_screen as a singleton
main_screen = Screen()</code></pre>
        <h3>Extending module load path</h3>
        <p>There are a couple of ways we could tell the Python interpreter where to look for modules, aside from the default, which is the local directory and the built-in modules. You could either use the environment variable PYTHONPATH to specify additional directories to look for modules in, like this:</p>
        <code>PYTHONPATH=/foo python game.py</code>
        <p>This will execute game.py, and will enable the script to load modules from the foo directory as well as the local directory.</p>
        <p>Another method is the sys.path.append function. You may execute it before running an import command:</p>
        <code>sys.path.append("/foo")</code>
        <p>This will add the foo directory to the list of paths to look for modules in as well.</p>
        <h3>Exploring built-in modules</h3>
        <p>Check out the full list of built-in modules in the Python standard library <a href="https://docs.python.org/3/library/">here</a>.</p>
        <p>Two very important functions come in handy when exploring modules in Python - the dir and help functions.</p>
        <p>If we want to import the module urllib, which enables us to create read data from URLs, we simply import the module:</p>
<pre><code># import the library
import urllib

# use it
urllib.urlopen(...)</code></pre>
        <p>We can look for which functions are implemented in each module by using the dir function:</p>
<pre><code>>>> import urllib
>>> dir(urllib)
['ContentTooShortError', 'FancyURLopener', 'MAXFTPCACHE', 'URLopener', '__all__', '__builtins__', 
'__doc__', '__file__', '__name__', '__package__', '__version__', '_ftperrors', '_get_proxies', 
'_get_proxy_settings', '_have_ssl', '_hexdig', '_hextochr', '_hostprog', '_is_unicode', '_localhost', 
'_noheaders', '_nportprog', '_passwdprog', '_portprog', '_queryprog', '_safe_map', '_safe_quoters', 
'_tagprog', '_thishost', '_typeprog', '_urlopener', '_userprog', '_valueprog', 'addbase', 'addclosehook', 
'addinfo', 'addinfourl', 'always_safe', 'basejoin', 'c', 'ftpcache', 'ftperrors', 'ftpwrapper', 'getproxies', 
'getproxies_environment', 'getproxies_macosx_sysconf', 'i', 'localhost', 'main', 'noheaders', 'os', 
'pathname2url', 'proxy_bypass', 'proxy_bypass_environment', 'proxy_bypass_macosx_sysconf', 'quote', 
'quote_plus', 'reporthook', 'socket', 'splitattr', 'splithost', 'splitnport', 'splitpasswd', 'splitport', 
'splitquery', 'splittag', 'splittype', 'splituser', 'splitvalue', 'ssl', 'string', 'sys', 'test', 'test1', 
'thishost', 'time', 'toBytes', 'unquote', 'unquote_plus', 'unwrap', 'url2pathname', 'urlcleanup', 'urlencode', 
'urlopen', 'urlretrieve']</code></pre>
        <p>When we find the function in the module we want to use, we can read about it more using the help function, inside the Python interpreter:</p>
        <code>help(urllib.urlopen)</code>
        <h3>Writing packages</h3>
        <p>Packages are namespaces which contain multiple packages and modules themselves. They are simply directories, but with a twist.</p>
        <p>Each package in Python is a directory which MUST contain a special file called __init__.py. This file can be empty, and it indicates that the directory it contains is a Python package, so it can be imported the same way a module can be imported.</p>
        <p>If we create a directory called foo, which marks the package name, we can then create a module inside that package called bar. We also must not forget to add the __init__.py file inside the foo directory.</p>
        <p>To use the module bar, we can import it in two ways:</p>
        <code>import foo.bar</code>
        <p>Or:</p>
        <code>from foo import bar</code>
        <p>In the first method, we must use the foo prefix whenever we access the module bar. In the second method, we don't, because we import the module to our module's namespace.</p>
        <p>The __init__.py file can also decide which modules the package exports as the API, while keeping other modules internal, by overriding the __all__ variable, like so:</p>
<pre><code>__init__.py:

__all__ = ["bar"]</code></pre>
      </section>
      <section id="References" class="main-section">
        <header><h2>References</h2></header>
        <p>All of the text for this tutorial comes from <a href="https://www.learnpython.org/">Learn Python, a website with free interactive tutorials</a>. I made a few changes here and there to fix grammatical errors or make things clear since my version of the tutorial is not interactive, but the original text is largely intact.</p>
      </section>
    </main>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>
